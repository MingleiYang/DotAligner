/*
 * main.cpp
 *
 *  Created on: Oct 28, 2013
 *      Author: Stefan Seemann, seemann@rth.dk
 *
 *  Implements an extension of the Needleman-Wunsch algorithm
 *  for global nucleotide sequence alignment
 *  that aligns two dotplots by taking care of relationships between two indices (basepairs).
 *
 *  Based on http://www.rolfmuertter.com/code/nw.php
 *
 */

#include "nwdp.h"

using namespace std;

int  main( int argc, char ** argv )
{
        char * program = *argv ;
        bool prm = false;
        bool seq = false;
        vector<float> prob_1;
        vector<float> prob_2;
        int len_1 = 0, len_2 = 0, len_1_aln = 0, len_2_aln = 0, len_1_last = 0, len_2_last = 0;
        string name1, name2, seq_1, seq_2;
        int precision = 2;
        int iter = -1;
        float dist = 0.;

        const float gappenalty = 4;

        if( argc < 3 )
        {
                cerr << "\n   Usage:   " << program << " file_1 file_2 [-p] [-seq]\n";
                cerr << "\n   Semi-local pairwise alignment of two base pair probability matrices.\n";
                cerr << "\n   file_[12]  fasta file with base pair probability matrix in the end (for example generated by RNAfold -p)";
                cerr << "\n   -p         print matrices";
                cerr << "\n   -seq       global pairwise alignment of two sequences\n";
                cerr << "\n   Debug modes:";
                cerr << "\n   -log            replace probabilities by expectation normalized log odds";
                cerr << "\n   -alpha <NR>     weight of sequence similarity (0..1; default = 0)";
                cerr << "\n   -gamma <NR>     gap costs (default = 4)";
                cerr << "\n   -extgaps        affine gap costs to differentiate between opening and extending gaps";
                cerr << "\n   -gammastem <NR> higher gap costs in base pair stacks of average probability greater than <NR> (0..1)\n";
                cerr << "\n   Output:         alignment\n\n";

                exit( 1 ) ;
        }

        // Sequences to be aligned
        string  filename1   =  argv[ 1 ] ;
        string  filename2   =  argv[ 2 ] ;

        for( int i=4; i<=5; i++ )
        {
        	if( argc >= i )
        	{
                string  pr_arg  =  argv[ i-1 ] ;
                if( pr_arg == "-p" ) prm = true;   // Print matrices
                if( pr_arg == "-seq" ) seq = true;   // calculate sequence alignment
        	}
        }

    	// read input file
        if( filename1.length() > 0 )
        {
            ifstream inputfile1;
            inputfile1.open(filename1.c_str());
            if( !inputfile1.is_open() ) {
                 cerr << "Could not open file " << filename1 << endl;
                 exit(EXIT_FAILURE);
            }
            len_1 = len_1_aln = readinput(inputfile1, name1, seq_1, prob_1);
            inputfile1.close();
        }
        if( filename2.length() > 0 )
        {
            ifstream inputfile2;
            inputfile2.open(filename2.c_str());
            if( !inputfile2.is_open() ) {
                 cerr << "Could not open file " << filename2 << endl;
                 exit(EXIT_FAILURE);
            }
            len_2 = len_2_aln = readinput(inputfile2, name2, seq_2, prob_2);
            inputfile2.close();
        }

        /* run global sequence alignment */
        if( seq )
        {
            /* aligned sequences */
            string seq_1_al;
            seq_1_al.reserve(2*len_1_aln);
            string seq_2_al;
            seq_2_al.reserve(2*len_2_aln);

            /* get sequence alignment */
            int dist = nw( seq_1, seq_2, seq_1_al, seq_2_al, prm ) ;

            /* print sequence alignment */
            cout << "Distance = " << dist << endl;
            print_al( seq_1_al, seq_2_al );

            return 0;
        }

        /* reduce depth of probability matrices */
        reducematrix(prob_1, len_1*len_1, precision);
        reducematrix(prob_2, len_2*len_2, precision);

        /* initialize arrays of indices */
		int *idx_1_aln = new int[len_1];
		for( int i=0; i<len_1; i++ ) idx_1_aln[ i ] = i;
		int *idx_2_aln = new int[len_2];
		for( int i=0; i<len_2; i++ ) idx_2_aln[ i ] = i;

        /* repeat aligning until no changes in alignment */
        while( len_1_last != len_1_aln || len_2_last != len_2_aln )
        {
 			#if DEBUG
        		cout << len_1_last << " " << len_1_aln << " " << len_2_last << " " << len_2_aln << endl;
			#endif
        	len_1_last = len_1_aln;
        	len_2_last = len_2_aln;

			/* align by Needleman-Wunsch algorithm all combinations of lines of both input probability matrices */
			float **distance = new float*[ len_2_last ];
			for( int j=0; j<len_2_last; j++ )
				distance[j] = new float[ len_1_last ];
			for( int j=0; j<len_2_last; j++ )
				for( int i=0; i<len_1_last; i++ )
					distance[ j ][ i ] = 0.;
			for( int j=0; j<len_2_last; j++)
				for( int i=0; i<len_1_last; i++)
					distance[ j ][ i ] = nwdp( prob_1, idx_1_aln[i]*len_1, idx_1_aln, len_1_last, prob_2, idx_2_aln[j]*len_2, idx_2_aln, len_2_last, gappenalty, prm );

			if( prm )
			{
				cout << "Distance matrix: " << endl;
				for( int j=0; j<len_2_last; j++) {
					for( int i=0; i<len_1_last; i++)
						cout << distance[ j ][ i ] << "\t";
					cout << endl;
				}
			}

			/* find best path through distance matrix */
			int *tmp_idx_1_aln = new int[len_1_last];
			int *tmp_idx_2_aln = new int[len_2_last];
			dist += nwdistance( distance, len_1_last, len_2_last, tmp_idx_1_aln, tmp_idx_2_aln, len_1_aln, len_2_aln, precision, gappenalty, prm);
			for( int i=0; i<len_1_aln; i++ ) idx_1_aln[ i ] = idx_1_aln[ tmp_idx_1_aln[ i ] ];
			for( int i=0; i<len_2_aln; i++ ) idx_2_aln[ i ] = idx_2_aln[ tmp_idx_2_aln[ i ] ];
			free(tmp_idx_1_aln);
			free(tmp_idx_2_aln);

			#if DEBUG
				cout << "Distance = " << dist << "\tGaps_1 = " << len_1-len_1_aln << "\tGaps_2 = " << len_2-len_2_aln << endl;
				for( int i=0; i<len_1_aln; i++ ) cout << idx_1_aln[ i ] << "\t";
				cout << endl;
				for( int j=0; j<len_2_aln; j++ ) cout << idx_2_aln[ j ] << "\t";
				cout << endl;

				cout << "prob_1: " << len_1_aln << endl;
				for( int i=0; i<len_1_aln; i++) for( int j=0; j<len_1_aln; j++ ) cout << prob_1[ idx_1_aln[ i ]*len_1 + idx_1_aln[ j ] ] << "\t"; cout << endl;
				cout << "prob_2: " << len_2_aln << endl;
				for( int i=0; i<len_2_aln; i++) for( int j=0; j<len_2_aln; j++ ) cout << prob_2[ idx_2_aln[ i ]*len_2 + idx_2_aln[ j ] ] << "\t"; cout << endl;
			#endif

			iter++;

			/* free memory */
	        freeMatrix(distance, len_2_last);
        }

        /* OUTPUT */
        /* adjust prob_1 and prob_2 by removing gap columns and rows */
        //has to be done

        /* calculate final distance */
        dist = 0;
        for( int i=0; i<len_1_aln; i++ )
        	dist += nwdp( prob_1, idx_1_aln[i]*len_1, idx_1_aln, len_1_aln, prob_2, idx_2_aln[i]*len_2, idx_2_aln, len_2_aln, gappenalty, prm );
        dist = dist / len_1_aln + gappenalty * ( (float) max(len_1, len_2) - len_1_aln ) / ( (float) max(len_1, len_2) );

        /* print aligned probabilities and distance */
        iter = ( !iter ) ? 1 : iter;
		cout << "Distance = " << dist << ", Length_1 = " << len_1 << ", Unaligned_1 = " << len_1-len_1_aln;
		cout << ", Length_2 = " << len_2 << ", Unaligned_2 = " << len_2-len_2_aln << ", Iterations = " << iter << endl;

		/* print sequences aligned by dot plot alignment */
		for( int i=0; i<len_1_aln; i++ ) cout << idx_1_aln[ i ] << ","; cout << endl;
		for( int j=0; j<len_2_aln; j++ ) cout << idx_2_aln[ j ] << ","; cout << endl;
		printalign(seq_1, idx_1_aln, seq_2, idx_2_aln, len_1_aln);

		/* free memory */
        delete[] idx_1_aln;
        delete[] idx_2_aln;

        return  0;
}
